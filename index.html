<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Keyblade Chronicles Character Creator</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background: linear-gradient(to bottom, #1a1a2e, #16213e);
            color: white;
            padding: 20px;
            margin: 0;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
            display: flex;
            gap: 20px;
        }
        .left-column {
            flex: 1;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
        }
        .right-column {
            flex: 1;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            position: relative; /* To contain absolutely positioned descriptions */
            min-height: 500px; /* Ensure enough height for all descriptions */
        }
        .description-item {
            position: absolute;
            width: 100%; /* Full width of right column */
            margin-bottom: 10px;
            display: none; /* Hidden until selected */
            left: 0; /* Align to the left edge of the right column */
        }
        label {
            display: block;
            margin-top: 10px;
            font-weight: bold;
        }
        select, input, button {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            font-size: 16px;
            border-radius: 5px;
            box-sizing: border-content;
        }
        .stat-select {
            width: 60px; /* Small dropdown for 2-digit numbers */
            display: inline-block;
            margin-left: 10px;
        }
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
            margin-top: 10px;
        }
        button:hover {
            background-color: #45a049;
        }
        #stats {
            margin: 10px 0;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        .stat-columns {
            display: flex;
            width: 100%;
            gap: 10px;
        }
        .stat-column {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        #abilities {
            margin: 10px 0;
        }
        #dice-rolls {
            margin: 5px 0;
            font-style: italic;
        }
        #output {
            margin-top: 20px;
            padding: 10px;
            background: #2a2a4a;
            border-radius: 5px;
        }
        h1 {
            text-align: center;
        }
    </style>
</head>
<body>
    <h1>Keyblade Chronicles Character Creator</h1>
    <div class="container">
        <div class="left-column">
            <div>
                <label for="name">Name:</label>
                <input type="text" id="name" placeholder="Enter your character's name">
            </div>
            <div>
                <label for="path">Path:</label>
                <select id="path" onchange="updateDescription('path'); updateAbilitiesBasedOnRole();">
                    <option value="" disabled selected>Select a Path</option>
                    <option value="Light Bearer">Light Bearer</option>
                    <option value="Shadow Striker">Shadow Striker</option>
                    <option value="Spellblade">Spellblade</option>
                    <option value="Stalwart Blade">Stalwart Blade</option>
                    <option value="Swift Blade">Swift Blade</option>
                    <option value="Time Blade">Time Blade</option>
                </select>
            </div>
            <div>
                <button onclick="rollStats()">Roll Stats</button>
                <div id="dice-rolls"></div>
                <div id="stats">
                    <div style="width: 100%;">
                        <p>HP: <span id="hp">-</span></p>
                    </div>
                    <div class="stat-columns">
                        <div class="stat-column">
                            <p>MP: <span id="mp">-</span> <select id="mp-select" class="stat-select" onchange="assignStat('mp')"></select></p>
                            <p>Str: <span id="str">-</span> <select id="str-select" class="stat-select" onchange="assignStat('str')"></select></p>
                            <p>Luck: <span id="luck">-</span> <select id="luck-select" class="stat-select" onchange="assignStat('luck')"></select></p>
                        </div>
                        <div class="stat-column">
                            <p>Def: <span id="def">-</span> <select id="def-select" class="stat-select" onchange="assignStat('def')"></select></p>
                            <p>AP: <span id="ap">-</span> <select id="ap-select" class="stat-select" onchange="assignStat('ap')"></select></p>
                        </div>
                    </div>
                </div>
            </div>
            <div id="abilities" style="display: none;">
                <label>Abilities</label>
                <p>AP Left: <span id="ap-left">0</span></p>
                <div id="ability-1">
                    <select id="ability-select-1" onchange="assignAbility(1)">
                        <option value="" selected>Select an Ability</option>
                    </select>
                </div>
                <div id="ability-2">
                    <select id="ability-select-2" onchange="assignAbility(2)">
                        <option value="" selected>Select an Ability</option>
                    </select>
                </div>
            </div>
            <div>
                <label for="keyblade">Keyblade:</label>
                <select id="keyblade" onchange="updateDescription('keyblade')">
                    <option value="" disabled selected>Select a Keyblade</option>
                    <option value="Kingdom Key">Kingdom Key</option>
                    <option value="Way to Dawn">Way to Dawn</option>
                    <option value="Star Seeker">Star Seeker</option>
                    <option value="Earthshaker">Earthshaker</option>
                    <option value="Oathkeeper">Oathkeeper</option>
                    <option value="Rainfell">Rainfell</option>
                </select>
            </div>
            <div>
                <label for="equipment">Equipment:</label>
                <select id="equipment" onchange="updateDescription('equipment')">
                    <option value="" disabled selected>Select an Accessory</option>
                    <option value="Light Charm">Light Charm</option>
                    <option value="Shadow Veil">Shadow Veil</option>
                    <option value="Ether Crystal">Ether Crystal</option>
                    <option value="Defender’s Crest">Defender’s Crest</option>
                    <option value="Trick Coin">Trick Coin</option>
                    <option value="Hourglass Pendant">Hourglass Pendant</option>
                </select>
            </div>
            <div>
                <label for="spell1">Spell 1:</label>
                <select id="spell1" onchange="updateSpellOptions('spell1')">
                    <option value="" disabled selected>Select a Spell</option>
                    <option value="Fire">Fire</option>
                    <option value="Blizzard">Blizzard</option>
                    <option value="Thunder">Thunder</option>
                    <option value="Cure">Cure</option>
                </select>
                <div id="spell2Container" style="display: none;">
                    <label for="spell2">Spell 2 (Spellblade only):</label>
                    <select id="spell2" onchange="updateSpellOptions('spell2')">
                        <option value="" disabled selected>Select a Spell</option>
                        <option value="Fire">Fire</option>
                        <option value="Blizzard">Blizzard</option>
                        <option value="Thunder">Thunder</option>
                        <option value="Cure">Cure</option>
                    </select>
                </div>
            </div>
            <div>
                <label for="backstory">Backstory:</label>
                <input type="text" id="backstory" placeholder="A short backstory">
            </div>
            <button onclick="createCharacter()">Create Character</button>
            <div id="output"></div>
        </div>
        <div class="right-column">
            <div id="pathDescription" class="description-item"></div>
            <div id="keybladeDescription" class="description-item"></div>
            <div id="equipmentDescription" class="description-item"></div>
            <div id="abilityDescription-1" class="description-item"></div>
            <div id="abilityDescription-2" class="description-item"></div>
        </div>
    </div>

    <script>
        let character = {
            name: "",
            path: "",
            hp: 0,
            mp: 0,
            str: 0,
            def: 0,
            ap: 0,
            luck: 0,
            keyblade: "",
            equipment: "",
            spells: [],
            backstory: "",
            abilities: []
        };
        let originalRolls = [];
        let rollAssignments = []; // Store roll assignments with identifiers (e.g., [{id: "A", value: 6}, {id: "B", value: 2}, ...])
        let assignedRolls = {
            mp: null,
            str: null,
            def: null,
            ap: null,
            luck: null
        };
        let totalAP = 0; // Initial AP value will be set by assigned AP stat
        let remainingAP = 0;
        let selectedAbilities = [];
        let currentRoleAbilities = [];

        const roleAbilities = {
            "Light Bearer": {
                "Combo Strike": { apCost: 1, description: "When you hit with a Keyblade attack, roll 1d6. If it’s equal to or less than your Strength, deal extra damage equal to your Luck." },
                "Bond of Light": { apCost: 2, description: "Once per encounter, spend 1 MP to restore 2 HP to an ally whose HP is below half." },
                "Radiant Edge": { apCost: 2, description: "Spend 1 MP to deal +3 Fire damage on your next Keyblade attack, illuminating the battlefield." },
                "Shining Guard": { apCost: 1, description: "Once per encounter, reduce damage you take by your Luck until your next turn." }
            },
            "Shadow Striker": {
                "Dark Slash": { apCost: 2, description: "Spend 1 MP to add your Luck to your Strength for one attack’s damage, but lose 1 HP from the effort." },
                "Defiant Edge": { apCost: 1, description: "When your HP drops below half, your next Keyblade attack deals +2 damage." },
                "Abyssal Bolt": { apCost: 2, description: "Spend 1 MP to deal +3 Thunder damage on your next Keyblade attack, crackling with dark energy." },
                "Shadow Step": { apCost: 1, description: "Once per encounter, roll 1d6. If it’s equal to or less than your Luck, avoid the next attack against you." }
            },
            "Spellblade": {
                "Spell Strike": { apCost: 2, description: "Spend 1 MP to add your MP score to your next Keyblade attack’s damage." },
                "Arcane Surge": { apCost: 1, description: "Once per encounter, roll 1d6 after hitting with a Keyblade. If it’s equal to or less than your Luck, regain 1 MP." },
                "Frost Blade": { apCost: 2, description: "Spend 1 MP to deal +3 Blizzard damage on your next Keyblade attack, chilling your foe." },
                "Mending Light": { apCost: 2, description: "Spend 2 MP to restore HP equal to your MP score to yourself or an ally, once per encounter." }
            },
            "Stalwart Blade": {
                "Guard Strike": { apCost: 1, description: "Attack with your Keyblade and reduce the next attack’s damage against an ally by your Defense." },
                "Heart’s Wall": { apCost: 2, description: "Once per encounter, when an ally takes damage, redirect half of it (rounded down) to yourself." },
                "Taunting Blade": { apCost: 2, description: "Spend 1 MP to force an enemy to attack you with its next action, drawing their ire with a defiant strike." },
                "Iron Stance": { apCost: 1, description: "Once per encounter, increase your Defense by 2 until your next turn." }
            },
            "Swift Blade": {
                "Lucky Evade": { apCost: 2, description: "When an attack would hit you, roll 1d6. If it’s equal to or less than your Luck, avoid the damage." },
                "Double Slash": { apCost: 1, description: "Attack with your Keyblade and roll 1d6. If it’s equal to or less than your Strength, make a second attack for free." },
                "Wind Cutter": { apCost: 2, description: "Spend 1 MP to deal +3 damage on your next Keyblade attack, slashing with a gust of wind." },
                "Fleet Foot": { apCost: 1, description: "Once per encounter, roll 1d6. If it’s equal to or less than your Luck, move to any position without penalty." }
            },
            "Time Blade": {
                "Chrono Slash": { apCost: 2, description: "Spend 1 MP to force an enemy to reroll its last attack or action. You choose which result they keep." },
                "Time Ward": { apCost: 1, description: "Once per encounter, roll 1d6. If it’s equal to or less than your Luck, reduce the next damage you or an ally takes by your Defense." },
                "Thunder Pulse": { apCost: 2, description: "Spend 1 MP to deal +3 Thunder damage on your next Keyblade attack, striking with timed precision." },
                "Moment’s Grace": { apCost: 2, description: "Spend 1 MP to act again immediately after your turn, once per encounter." }
            }
        };

        const descriptions = {
            path: {
                "Light Bearer": "A champion of hope and friendship, like Sora. Light Bearers wield their Keyblades with balance and heart, blending combat and support.",
                "Shadow Striker": "A warrior embracing the edge of darkness, like Riku. Shadow Strikers wield their Keyblade with raw power, risking themselves for devastating strikes.",
                "Spellblade": "A magical Keyblade master, like Donald or Mickey. Spellblades fuse spells and strikes, wielding their Keyblade as a conduit for arcane might.",
                "Stalwart Blade": "A protector of allies, like Goofy or Terra. Stalwart Blades wield their Keyblade to shield and endure, standing as a bulwark against harm.",
                "Swift Blade": "A nimble and cunning wielder, like Roxas or Ventus. Swift Blades dance through combat, striking fast and trusting luck to prevail.",
                "Time Blade": "A temporal Keyblade master, like Aqua. Time Blades wield their Keyblade with precision, blending magic and control to bend battle’s flow."
            },
            keyblade: {
                "Kingdom Key": "A simple, iconic blade of light and balance, wielded by Sora.",
                "Way to Dawn": "A shadowed Keyblade of dusk and redemption, favored by Riku.",
                "Star Seeker": "A star-tipped blade pulsing with magical potential, tied to Mickey’s lineage.",
                "Earthshaker": "A rugged, heavy Keyblade of unyielding strength, once Terra’s.",
                "Oathkeeper": "A sleek, swift blade of promise and memory, linked to Roxas and Sora.",
                "Rainfell": "A graceful, flowing Keyblade of time and elegance, Aqua’s chosen weapon."
            },
            equipment: {
                "Light Charm": "Reroll one failed Luck check per session. A token of hope for Light Bearers.",
                "Shadow Veil": "The first attack against you in combat has a -1 penalty to hit. A dark shroud for Shadow Strikers.",
                "Ether Crystal": "Restore 2 MP once per session. A mystic gem for Spellblades.",
                "Defender’s Crest": "Add 1 to your Defense when protecting an ally. A sturdy emblem for Stalwart Blades.",
                "Trick Coin": "Flip it once per session: heads doubles your Luck for one roll, tails halves it. A gambler’s tool for Swift Blades.",
                "Hourglass Pendant": "Regain 1 MP when you use a spell or ability, once per session. A timely relic for Time Blades."
            }
        };

        function updateDescription(type) {
            const value = document.getElementById(type).value;
            const descriptionItem = document.getElementById(`${type}Description`);

            if (value && descriptions[type][value]) {
                descriptionItem.style.display = 'block';
                descriptionItem.innerHTML = descriptions[type][value];
                const rect = document.getElementById(type).getBoundingClientRect();
                const rightColumn = document.querySelector('.right-column');
                descriptionItem.style.top = `${rect.top + window.scrollY - 90}px`;
                descriptionItem.style.left = `${0}px`;
            } else {
                descriptionItem.style.display = 'none';
            }

            // Show/hide Spell 2 for Spellblade
            if (type === "path" && value === "Spellblade") {
                document.getElementById('spell2Container').style.display = 'block';
                updateSpellOptions('spell1');
            } else if (type === "path" && value !== "Spellblade") {
                document.getElementById('spell2Container').style.display = 'none';
                character.spells = [document.getElementById('spell1').value];
                updateSpellOptions('spell1');
            }

            // Update ability descriptions
            for (let i = 1; i <= 2; i++) {
                const abilityId = `ability-select-${i}`;
                const abilityDescId = `abilityDescription-${i}`;
                const abilityValue = document.getElementById(abilityId) ? document.getElementById(abilityId).value : '';
                const descItem = document.getElementById(abilityDescId);
                if (abilityValue && roleAbilities[character.path][abilityValue]) {
                    descItem.style.display = 'block';
                    descItem.innerHTML = roleAbilities[character.path][abilityValue].description;
                    const rect = document.getElementById(abilityId).getBoundingClientRect();
                    descItem.style.top = `${rect.top + window.scrollY - 90}px`;
                    descItem.style.left = `${0}px`;
                } else {
                    descItem.style.display = 'none';
                }
            }
        }

        function updateAbilitiesBasedOnRole() {
            const role = document.getElementById('path').value;
            character.path = role; // Update character path
            if (role && roleAbilities[role]) {
                currentRoleAbilities = roleAbilities[role];
                selectedAbilities = [];
                // Set remainingAP to the assigned AP value, default to 0 if not set
                remainingAP = character.ap || 0;
                document.getElementById('ap-left').textContent = remainingAP;
                document.getElementById('abilities').style.display = 'block';
                for (let i = 1; i <= 2; i++) {
                    const abilityDiv = document.getElementById(`ability-${i}`);
                    abilityDiv.style.display = 'block';
                }
                updateAbilityDropdowns();
            } else {
                document.getElementById('abilities').style.display = 'none';
                currentRoleAbilities = {};
                selectedAbilities = [];
                remainingAP = character.ap || 0;
                document.getElementById('ap-left').textContent = remainingAP;
            }
        }

        function updateSpellOptions(changedSpell) {
            const spell1 = document.getElementById('spell1');
            const spell2 = document.getElementById('spell2');
            const spellOptions = ["", "Fire", "Blizzard", "Thunder", "Cure"];

            const spell1Value = spell1.value;
            const spell2Value = spell2.value;

            if (changedSpell === 'spell1') {
                const currentSpell2 = spell2.value;
                spell2.innerHTML = '';
                spellOptions.forEach(option => {
                    if (option === spell1Value) return;
                    const opt = document.createElement('option');
                    opt.value = option;
                    opt.text = option || "Select a Spell";
                    if (option === "") opt.disabled = true;
                    if (option === currentSpell2) opt.selected = true;
                    spell2.appendChild(opt);
                });
            } else if (changedSpell === 'spell2') {
                const currentSpell1 = spell1.value;
                spell1.innerHTML = '';
                spellOptions.forEach(option => {
                    if (option === spell2Value) return;
                    const opt = document.createElement('option');
                    opt.value = option;
                    opt.text = option || "Select a Spell";
                    if (option === "") opt.disabled = true;
                    if (option === currentSpell1) opt.selected = true;
                    spell1.appendChild(opt);
                });
            }
        }

        function rollStats() {
            let rolls = Array(5).fill().map(() => Math.floor(Math.random() * 6) + 1); // Roll 5d6 for stats
            let hpRolls = rolls.slice(0, 4); // Use first 4 for HP
            hpRolls.sort((a, b) => a - b).shift(); // Drop lowest
            character.hp = hpRolls.reduce((sum, val) => sum + val, 0);

            // Assign each roll a unique identifier (A, B, C, D, E)
            const identifiers = ["A", "B", "C", "D", "E"];
            rollAssignments = rolls.map((roll, index) => ({
                id: identifiers[index],
                value: roll
            }));

            // Display individual rolls
            document.getElementById('dice-rolls').innerHTML = `Dice Rolled: ${rollAssignments.map(r => r.value).join(', ')}`;

            // Reset assigned rolls and abilities
            assignedRolls = {
                mp: null,
                str: null,
                def: null,
                ap: null,
                luck: null
            };
            character.mp = 0;
            character.str = 0;
            character.def = 0;
            character.ap = 0;
            character.luck = 0;
            document.getElementById('hp').textContent = character.hp;
            document.getElementById('mp').textContent = '-';
            document.getElementById('str').textContent = '-';
            document.getElementById('def').textContent = '-';
            document.getElementById('ap').textContent = '-';
            document.getElementById('luck').textContent = '-';
            remainingAP = character.ap || 0; // Set remainingAP to the assigned AP value
            selectedAbilities = [];
            document.getElementById('ap-left').textContent = remainingAP;
            updateAbilityDropdowns();

            // Populate dropdowns with available rolls
            updateStatDropdowns();
        }

        function updateStatDropdowns() {
            const stats = ['mp', 'str', 'def', 'ap', 'luck'];
            let assignedIds = stats.map(s => assignedRolls[s]).filter(id => id !== null);

            stats.forEach(stat => {
                const select = document.getElementById(`${stat}-select`);
                const currentId = assignedRolls[stat];
                const currentValue = currentId ? rollAssignments.find(r => r.id === currentId).value : 0;
                select.innerHTML = '';
                const optDefault = document.createElement('option');
                optDefault.value = '';
                optDefault.text = 'Select';
                optDefault.disabled = false;
                if (!currentId) optDefault.selected = true;
                select.appendChild(optDefault);

                rollAssignments.forEach(roll => {
                    if (!assignedIds.includes(roll.id) || roll.id === currentId) {
                        const opt = document.createElement('option');
                        opt.value = roll.id;
                        opt.text = roll.value.toString();
                        if (roll.id === currentId) opt.selected = true;
                        select.appendChild(opt);
                    }
                });
            });

            // Update remainingAP when AP is assigned
            if (stat === 'ap' && currentId) {
                remainingAP = currentValue;
                document.getElementById('ap-left').textContent = remainingAP;
                updateAbilityDropdowns();
            }
        }

        function updateAbilityDropdowns() {
            const maxAbilities = 2;
            for (let i = 1; i <= maxAbilities; i++) {
                const select = document.getElementById(`ability-select-${i}`);
                if (select) {
                    const currentAbility = selectedAbilities[i - 1] || '';
                    select.innerHTML = '';
                    const optDefault = document.createElement('option');
                    optDefault.value = '';
                    optDefault.text = 'Select an Ability';
                    optDefault.disabled = false;
                    if (!currentAbility) optDefault.selected = true;
                    select.appendChild(optDefault);

                    // Exclude abilities selected in the other dropdown
                    const otherIndex = i === 1 ? 2 : 1;
                    const otherAbility = selectedAbilities[otherIndex - 1] || '';

                    for (let ability in currentRoleAbilities) {
                        const apCost = currentRoleAbilities[ability].apCost;
                        if (apCost <= remainingAP && ability !== otherAbility && !selectedAbilities.includes(ability)) {
                            const opt = document.createElement('option');
                            opt.value = ability;
                            opt.text = `${ability} (${apCost} AP)`;
                            if (ability === currentAbility) opt.selected = true;
                            select.appendChild(opt);
                        }
                    }
                }
            }
        }

        function assignAbility(index) {
            const select = document.getElementById(`ability-select-${index}`);
            const ability = select.value;
            if (ability && !selectedAbilities.includes(ability)) {
                // Remove previous ability if it exists at this index
                const previousAbility = selectedAbilities[index - 1];
                if (previousAbility && currentRoleAbilities[previousAbility]) {
                    remainingAP += currentRoleAbilities[previousAbility].apCost;
                }
                selectedAbilities[index - 1] = ability;
                remainingAP -= currentRoleAbilities[ability].apCost;
                document.getElementById('ap-left').textContent = remainingAP;
                character.abilities = selectedAbilities.filter(a => a); // Update character abilities
                updateDescription('ability'); // Update ability description
                updateAbilityDropdowns(); // Update dropdown options
            } else if (ability === '' && selectedAbilities[index - 1]) {
                // Unassign ability
                const previousAbility = selectedAbilities[index - 1];
                remainingAP += currentRoleAbilities[previousAbility].apCost;
                selectedAbilities[index - 1] = null;
                document.getElementById('ap-left').textContent = remainingAP;
                character.abilities = selectedAbilities.filter(a => a);
                updateDescription('ability');
                updateAbilityDropdowns();
            }
        }

        function assignStat(stat) {
            const select = document.getElementById(`${stat}-select`);
            const selectedId = select.value;
            if (selectedId || selectedId === '') {
                const previousId = assignedRolls[stat];
                if (previousId) {
                    // No need to manage frequencies since we're using IDs
                }

                assignedRolls[stat] = selectedId === '' ? null : selectedId;
                character[stat] = selectedId === '' ? 0 : rollAssignments.find(r => r.id === selectedId).value;
                document.getElementById(stat).textContent = character[stat] || '-';

                // Update remainingAP when AP is assigned
                if (stat === 'ap') {
                    remainingAP = character.ap || 0;
                    document.getElementById('ap-left').textContent = remainingAP;
                    updateAbilityDropdowns();
                }

                updateStatDropdowns();
            }
        }

        function createCharacter() {
            character.name = document.getElementById('name').value || "Unnamed Wielder";
            character.path = document.getElementById('path').value;
            character.keyblade = document.getElementById('keyblade').value;
            character.equipment = document.getElementById('equipment').value;

            let spell1 = document.getElementById('spell1').value;
            character.spells = [spell1];
            if (character.path === "Spellblade") {
                let spell2 = document.getElementById('spell2').value;
                if (spell2 && spell2 !== spell1) character.spells.push(spell2);
            }

            character.backstory = document.getElementById('backstory').value || "A mysterious hero.";
            character.abilities = selectedAbilities.filter(a => a);

            let output = `
                Name: ${character.name}<br>
                Path: ${character.path}<br>
                Stats: HP ${character.hp}, MP ${character.mp}, Str ${character.str}, Def ${character.def}, AP ${character.ap}, Luck ${character.luck}<br>
                Abilities: ${character.abilities.join(", ")}<br>
                Keyblade: ${character.keyblade}<br>
                Equipment: ${character.equipment}<br>
                Spells: ${character.spells.join(", ")}<br>
                Backstory: ${character.backstory}
            `;
            document.getElementById('output').innerHTML = output;
        }
    </script>
</body>
</html>
